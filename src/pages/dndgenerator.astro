---
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../consts';

export const prerender = false; // Server-side rendering

// Handle API calls
if (Astro.request.method === 'POST') {
  // Your worker logic here (the roll generation code)
  const body = await Astro.request.json();
  // ... process and return JSON
  return new Response(JSON.stringify(result), {
    headers: { 'Content-Type': 'application/json' }
  });
}
---

<!doctype html>
<html lang="en">
  <head>
    <BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
    <style>
      /* Copy all your worker's CSS here */
      .container {
        width: 100%;
        max-width: 920px;
        background: rgba(0,0,0,0.66);
        border: 3px solid #8b6f47;
        border-radius: 18px;
        padding: 36px;
        box-shadow: 0 12px 60px rgba(0,0,0,0.8);
        margin: 0 auto;
      }
      /* ... rest of your CSS ... */
    </style>
  </head>
  <body>
    <Header />
    
    <main>
      <div class="container">
        <h1>üé≤ Warlord's Magical Bag</h1>
        <p class="subtitle">Reach in and discover what fate has in store...</p>
        
        <!-- Copy your worker's HTML content here -->
        <div class="grid">
          <!-- All your form inputs -->
        </div>
        
        <button id="rollButton" onclick="rollForItem()">üé≤ Reach Into the Bag</button>
        <div id="result"></div>
      </div>
    </main>
    
    <Footer />
    
    <script>
      // Copy your worker's JavaScript here
      async function rollForItem() {
        // Make fetch call to same page
        const response = await fetch(window.location.pathname, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userLevel, goldSpent, useLucky, lockRoll, lockedRollValue })
        });
        // AUTH TOGGLE - Set to false to disable authentication
const AUTH_ENABLED = false;

const AUTH_USER = '1234';
const AUTH_PASS = '1234';

// D20 item mapping (1-20, each number always gives the same item type)
const ITEM_TABLE = {
  1: 'Book', 2: 'Potion', 3: 'Weapon', 4: 'Scroll', 5: 'Gemstone',
  6: 'Key', 7: 'Coin', 8: 'Trinket', 9: 'Tool', 10: 'Armor Piece',
  11: 'Map', 12: 'Wand', 13: 'Ring', 14: 'Amulet', 15: 'Herb',
  16: 'Musical Instrument', 17: 'Rope', 18: 'Lantern', 19: 'Food', 20: 'Mysterious Orb'
};

// Item conditions
const CONDITIONS = [
  'Burnt', 'Worn', 'Ruined', 'Bullet Hole', 'Infested', 'Tainted', 'Used',
  'Gilded', 'Scratched', 'Cracked', 'Pristine', 'Weathered', 'Bloodstained',
  'Dusty', 'Moldy', 'Corroded', 'Chipped', 'Frozen', 'Scorched', 'Dented'
];

// Item name generation prompts
const NAME_PROMPTS = {
  'Book': ['Tome', 'Journal', 'Spellbook', 'Diary', 'Chronicle', 'Grimoire', 'Fifty Shades of Gray', 'Harry Potter and the Sorcer Stone', 'Holy'],
  'Potion': ['Elixir', 'Brew', 'Vial', 'Mixture', 'Tonic', 'Draught', 'love Potion', 'Health Potion'],
  'Weapon': ['Dagger', 'Shortsword', 'Mace', 'Handaxe', 'Rapier', 'Warhammer', 'Spear'],
  'Scroll': ['Parchment', 'Scroll', 'Decree', 'Letter', 'Prophecy', 'Manuscript'],
  'Gemstone': ['Ruby', 'Sapphire', 'Emerald', 'Diamond', 'Opal', 'Amethyst', 'Dragonstone'],
  'Key': ['Key', 'Skeleton Key', 'Pass Key', 'Master Key', 'Crystal Key', 'Wagon Key', 'Chest Key'],
  'Coin': ['Gold Coin', 'Silver Coin', 'Currency', 'Token', 'Lucky Coin', 'Weighted Coin', 'Two Heads', 'Two Tails'],
  'Trinket': ['Figurine', 'Compass', 'Pocket Watch', 'Dice Set', 'Charm', 'Feather', 'Bracelet'],
  'Tool': ['Lockpick', 'Chisel', 'Hammer', 'Crowbar', 'Spyglass', 'Lever', 'level'],
  'Armor Piece': ['Gauntlet', 'Pauldron', 'Helmet', 'Breastplate', 'Shield', 'Chainmail', 'Plate'],
  'Map': ['Map', 'Chart', 'Layout', 'Atlas', 'Guide', 'Treasure Map', 'Town Map' ],
  'Wand': ['Wand', 'Rod', 'Staff', 'Stick', 'Branch'],
  'Ring': ['Ring', 'Band', 'Loop', 'Circle', 'Signet'],
  'Amulet': ['Pendant', 'Medallion', 'Talisman', 'Charm', 'Symbol'],
  'Herb': ['Herb', 'Flower', 'Root', 'Leaf', 'Spice'],
  'Musical Instrument': ['Flute', 'Lute', 'Drum', 'Horn', 'Harp'],
  'Rope': ['Rope', 'Cord', 'Chain', 'Cable', 'Line'],
  'Lantern': ['Lantern', 'Lamp', 'Torch', 'Light', 'Beacon'],
  'Food': ['Rations', 'Cheese', 'Bread', 'Meat', 'Fruit'],
  'Mysterious Orb': ['Orb', 'Sphere', 'Globe', 'Ball', 'Crystal']
};

const MODIFIERS = [
  'Ancient', 'Forgotten', 'Mysterious', 'Gleaming', 'Shadowy',
  'Blessed', 'Cursed', 'Enchanted', 'Ethereal', 'Radiant',
  'Dark', 'Shimmering', 'Ornate', 'Simple', 'Arcane'
];

// Spell lists by level
const CANTRIPS = [
  'Light', 'Mage Hand', 'Prestidigitation', 'Minor Illusion', 'Fire Bolt',
  'Ray of Frost', 'Shocking Grasp', 'Acid Splash', 'Dancing Lights', 'Thaumaturgy'
];

const LOW_LEVEL_SPELLS = [
  'Magic Missile', 'Burning Hands', 'Cure Wounds', 'Shield', 'Sleep',
  'Thunderwave', 'Charm Person', 'Detect Magic', 'Jump', 'Feather Fall'
];

const MID_LEVEL_SPELLS = [
  'Fireball', 'Lightning Bolt', 'Fly', 'Counterspell', 'Dispel Magic',
  'Haste', 'Slow', 'Revivify', 'Spirit Guardians', 'Hypnotic Pattern'
];

const HIGH_LEVEL_SPELLS = [
  'Greater Invisibility', 'Polymorph', 'Wall of Fire', 'Banishment',
  'Dimension Door', 'Stone Skin', 'Ice Storm', 'Confusion'
];

const VERY_HIGH_LEVEL_SPELLS = [
  'Cone of Cold', 'Telekinesis', 'Scrying', 'Cloudkill', 'Dominate Person',
  'Hold Monster', 'Wall of Force', 'Teleportation Circle'
];

const MAX_LEVEL_SPELLS = [
  'Disintegrate', 'Chain Lightning', 'True Seeing', 'Blade Barrier',
  'Sunbeam', 'Meteor Swarm', 'Time Stop', 'Power Word Kill', 'Wish'
];

// Magical properties
const COMMON_EFFECTS = [
  'Glows faintly in the dark',
  'Feels slightly warm to the touch',
  'Emits a faint humming sound',
  'Changes color based on mood',
  'Never gets dirty',
  'Always smells like lavender',
  'Occasionally whispers nonsense',
  'Repels small insects'
];

const NEGATIVE_EFFECTS = [
  'Makes user smell like sulfur',
  'Causes mild headaches',
  'Attracts flies',
  'Makes food taste bland',
  'Causes minor nightmares',
  "User's shadow moves independently",
  'Drains 1 HP per use',
  'Makes user sneeze occasionally'
];

const COSMETIC_EFFECTS = [
  "Changes user's eye color",
  "Changes user's skin to a random color",
  "Makes user's hair glow",
  "User appears 10 years older/younger",
  "User's voice becomes musical",
  "User leaves glittery footprints",
  "User casts colorful shadows",
  "User's hair changes color daily"
];

const DAMAGE_TYPES = [
  'Fire', 'Cold', 'Lightning', 'Thunder', 'Poison', 'Acid',
  'Necrotic', 'Radiant', 'Force', 'Psychic', 'Piercing', 'Slashing', 'Bludgeoning'
];

function getRandomDamageType() {
  return DAMAGE_TYPES[Math.floor(Math.random() * DAMAGE_TYPES.length)];
}

function getRandomDamageTypes(count) {
  const types = [];
  const available = [...DAMAGE_TYPES];
  for (let i = 0; i < count && available.length > 0; i++) {
    const index = Math.floor(Math.random() * available.length);
    types.push(available.splice(index, 1)[0]);
  }
  return types.join(' and ');
}

const POSITIVE_EFFECTS = [
  '+1 to AC',
  '+1 to attack rolls',
  '+10 ft movement speed',
  'Advantage on perception checks',
  () => `Resistance to ${getRandomDamageType()} damage`,
  '+2 to initiative',
  'Darkvision 60 ft',
  '+1 to saving throws'
];

const VERY_POSITIVE_EFFECTS = [
  '+2 to AC',
  '+2 to attack and damage rolls',
  '+20 ft movement speed',
  'Advantage on all saving throws',
  () => `Resistance to ${getRandomDamageTypes(2)} damage`,
  '+5 to initiative',
  'Darkvision 120 ft',
  'Regenerate 1d4 HP per round'
];

const LEGENDARY_EFFECTS = [
  '+3 to AC',
  '+3 to attack and damage rolls',
  '+30 ft movement speed and can fly',
  () => `Immunity to ${getRandomDamageType()} damage`,
  'Advantage on all checks and saves',
  'Truesight 60 ft',
  'Regenerate 2d6 HP per round',
  'Cast one additional spell per day'
];

// Calculate rarity based on gold
// This preserves original tiers and adds Artifact / Ultra Artifact for higher gold
function getRarity(gold) {
  if (gold < 50) return null;
  if (gold < 100) return 'Common';
  if (gold < 150) return 'Uncommon';
  if (gold < 200) return 'Rare';
  if (gold < 250) return 'Very Rare';
  if (gold < 300) return 'Legendary';
  // artifact range (255-354)
  if (gold < 355) return 'Artifact';
  // beyond that is Ultra Artifact
  return 'Ultra Artifact';
}

// Generate magical properties based on rarity
function generateMagicalProperties(rarity, userLevel, isLucky) {
  if (!isLucky) return null;
  
  const properties = {
    rarity: rarity,
    requiresAttunement: false,
    spellType: null,
    spell: null,
    charges: null,
    recharge: null,
    additionalEffect: null
  };
  
  const rand = (arr) => arr[Math.floor(Math.random() * arr.length)];
  
  switch(rarity) {
    case 'Common':
      properties.spellType = Math.random() > 0.7 ? 'spell' : 'cantrip';
      if (properties.spellType === 'cantrip') {
        properties.spell = rand(CANTRIPS);
        properties.charges = 'Unlimited';
      } else {
        properties.spell = rand(LOW_LEVEL_SPELLS);
        properties.charges = 1;
        properties.recharge = 'No recharge';
      }
      properties.additionalEffect = Math.random() > 0.5 ? rand(NEGATIVE_EFFECTS) : rand(COMMON_EFFECTS);
      break;
      
    case 'Uncommon':
      properties.spellType = 'spell';
      properties.spell = Math.random() > 0.8 ? rand(MID_LEVEL_SPELLS) : rand(LOW_LEVEL_SPELLS);
      properties.charges = 2;
      properties.recharge = 'No recharge';
      properties.additionalEffect = rand(COSMETIC_EFFECTS);
      break;
      
    case 'Rare':
      properties.requiresAttunement = true;
      properties.spellType = 'spell';
      if (userLevel <= 5) properties.spell = rand(LOW_LEVEL_SPELLS);
      else if (userLevel <= 10) properties.spell = rand(MID_LEVEL_SPELLS);
      else properties.spell = rand(HIGH_LEVEL_SPELLS);
      properties.charges = 3;
      properties.recharge = 'Long rest';
      properties.additionalEffect = rand(POSITIVE_EFFECTS);
      if (typeof properties.additionalEffect === 'function') {
        properties.additionalEffect = properties.additionalEffect();
      }
      break;
      
    case 'Very Rare':
      properties.requiresAttunement = true;
      properties.spellType = 'spell';
      if (userLevel <= 5) {
        properties.spell = Math.random() > 0.8 ? rand(MID_LEVEL_SPELLS) : rand(LOW_LEVEL_SPELLS);
      } else if (userLevel <= 10) {
        properties.spell = Math.random() > 0.8 ? rand(HIGH_LEVEL_SPELLS) : rand(MID_LEVEL_SPELLS);
      } else {
        properties.spell = Math.random() > 0.8 ? rand(VERY_HIGH_LEVEL_SPELLS) : rand(HIGH_LEVEL_SPELLS);
      }
      properties.charges = 5;
      properties.recharge = 'Long rest';
      properties.additionalEffect = rand(VERY_POSITIVE_EFFECTS);
      if (typeof properties.additionalEffect === 'function') {
        properties.additionalEffect = properties.additionalEffect();
      }
      break;
      
    case 'Legendary':
      properties.requiresAttunement = true;
      properties.spellType = 'spell';
      properties.spell = rand(MAX_LEVEL_SPELLS);
      properties.charges = 8;
      properties.recharge = 'Long rest';
      properties.additionalEffect = rand(LEGENDARY_EFFECTS);
      if (typeof properties.additionalEffect === 'function') {
        properties.additionalEffect = properties.additionalEffect();
      }
      break;
      
    case 'Artifact':
      properties.requiresAttunement = true;
      properties.spellType = 'spell';
      properties.spell = rand(MAX_LEVEL_SPELLS);
      properties.charges = 10;
      properties.recharge = 'Dawn';
      const effect1 = rand(LEGENDARY_EFFECTS);
      const effect2 = rand(LEGENDARY_EFFECTS);
      properties.additionalEffect = (typeof effect1 === 'function' ? effect1() : effect1) + 
        ' + ' + (typeof effect2 === 'function' ? effect2() : effect2);
      break;
      
    case 'Ultra Artifact':
      // Extra flashy / enhanced magical properties
      properties.requiresAttunement = true;
      properties.spellType = 'spell';
      properties.spell = rand(MAX_LEVEL_SPELLS);
      properties.charges = '‚àû';
      properties.recharge = 'Self-Recharging';
      const e3 = rand(LEGENDARY_EFFECTS), e4 = rand(LEGENDARY_EFFECTS), e5 = rand(LEGENDARY_EFFECTS);
      properties.additionalEffect = `${typeof e3 === 'function' ? e3() : e3} + ${typeof e4 === 'function' ? e4() : e4} + ${typeof e5 === 'function' ? e5() : e5}`;
      break;
  }
  
  return properties;
}

// Authentication middleware
function checkAuth(request) {
  const authHeader = request.headers.get('Authorization');
  if (!authHeader || !authHeader.startsWith('Basic ')) return false;
  try {
    const base64Credentials = authHeader.split(' ')[1];
    const credentials = atob(base64Credentials);
    const [username, password] = credentials.split(':');
    return username === AUTH_USER && password === AUTH_PASS;
  } catch (e) {
    return false;
  }
}

function unauthorizedResponse() {
  return new Response('Unauthorized', {
    status: 401,
    headers: { 'WWW-Authenticate': 'Basic realm="DND Item Generator", charset="UTF-8"' }
  });
}

function rollD20() {
  return Math.floor(Math.random() * 20) + 1;
}

function generateItemName(itemType) {
  const baseNames = NAME_PROMPTS[itemType] || ['Unknown Item'];
  const baseName = baseNames[Math.floor(Math.random() * baseNames.length)];
  
  if (Math.random() > 0.5) {
    const modifier = MODIFIERS[Math.floor(Math.random() * MODIFIERS.length)];
    return `${modifier} ${baseName}`;
  }
  
  if (Math.random() > 0.7) {
    const suffixes = ['of Power', 'of Wisdom', 'of the Ancients', 'of Shadows', 'of Light'];
    const suffix = suffixes[Math.floor(Math.random() * suffixes.length)];
    return `${baseName} ${suffix}`;
  }
  
  return baseName;
}

// Serve HTML page
function getHTML() {
  // Level 1..20 dropdown, gold 0..500 by 50, lockedRoll 1..20
  const levelOptions = Array.from({ length: 20 }, (_, i) => `<option value="${i+1}">${i+1}</option>`).join('');
  const goldOptions = Array.from({ length: 101 }, (_, i) => `<option value="${i*50}">${i*50}</option>`).join(''); // 0..500 step 50
  const lockedOptions = Array.from({ length: 20 }, (_, i) => `<option value="${i+1}">${i+1}</option>`).join('');
  
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Warlord's Magical Bag</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body { height: 100%; }
    body {
      font-family: 'Georgia', serif;
      background: linear-gradient(135deg, #1a0a2e 0%, #3d1a4d 100%);
      color: #f0e6d2;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      min-height: 100vh;
    }
    .container {
      width: 100%;
      max-width: 920px;
      background: rgba(0,0,0,0.66);
      border: 3px solid #8b6f47;
      border-radius: 18px;
      padding: 36px;
      box-shadow: 0 12px 60px rgba(0,0,0,0.8);
    }
    h1 {
      text-align: center;
      font-size: 2.8rem;
      color: #ffd700;
      text-shadow: 2px 2px 6px rgba(0,0,0,0.8);
      margin-bottom: 6px;
    }
    .subtitle {
      text-align: center;
      color: #c9b896;
      margin-bottom: 26px;
      font-style: italic;
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
      margin-bottom: 18px;
    }
    .input-group {
      background: rgba(139,111,71,0.12);
      padding: 14px;
      border-radius: 10px;
      border: 1px solid rgba(139,111,71,0.25);
    }
    label {
      display: block;
      margin-bottom: 8px;
      color: #ffd700;
      font-weight: bold;
    }
    select, input[type="checkbox"] {
      width: 100%;
      padding: 10px;
      border-radius: 6px;
      border: 2px solid #8b6f47;
      background: rgba(0,0,0,0.6);
      color: #f0e6d2;
      font-family: 'Georgia', serif;
      font-size: 1rem;
    }
    .checkbox-row {
      display:flex;
      gap:10px;
      align-items:center;
    }
    #rollButton {
      width: 100%;
      background: linear-gradient(135deg,#8b6f47 0%,#6b5437 100%);
      border: 2px solid #ffd700;
      color: #f0e6d2;
      font-size: 1.25rem;
      padding: 14px 20px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: bold;
      transition: transform .18s ease, box-shadow .18s ease;
    }
    #rollButton:hover { transform: translateY(-2px); box-shadow: 0 0 22px rgba(255,215,0,0.45); }
    #result {
      margin-top: 20px;
      padding: 22px;
      background: rgba(139,111,71,0.14);
      border-radius: 10px;
      border: 2px solid rgba(139,111,71,0.25);
      display: none;
    }
    #result.show { display: block; animation: fadeIn .45s ease; }
    @keyframes fadeIn { from{opacity:0; transform:translateY(16px);} to{opacity:1; transform:translateY(0);} }
    .dice-roll { font-size: 2rem; color: #ffd700; font-weight: bold; margin-bottom: 8px; }
    .item-header { font-size: 1.6rem; color: #ffd700; margin: 6px 0 10px 0; font-style: italic; }
    .item-detail { color: #c9b896; margin-bottom: 8px; }
    .rarity { display:inline-block; padding:6px 12px; border-radius:6px; font-weight:bold; margin:8px 0; }
    .rarity.Common { background:#808080; color:#fff; }
    .rarity.Uncommon { background:#1eff00; color:#000; }
    .rarity.Rare { background:#0070dd; color:#fff; }
    .rarity['Very Rare'] { background:#a335ee; color:#fff; }
    .rarity.Legendary { background:#ff8000; color:#fff; }
    .rarity.Artifact { background:#e6cc80; color:#8b0000; }
    .rarity['Ultra Artifact'] { background:linear-gradient(90deg,#ffeb3b,#ff9800,#ffeb3b); color:#5c2d00; text-shadow:0 0 6px #fff; font-weight:bold; }
    .magical-properties { background: rgba(255,215,0,0.06); padding: 12px; border-radius:8px; border-left:4px solid #ffd700; margin-top:10px; color:#f0e6d2; }
    .warning { color: #ff6b6b; margin-top:10px; font-style:italic; }
    /* single column on small screens */
    @media (max-width: 720px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé≤ Warlord's Magical Bag</h1>
    <p class="subtitle">Reach in and discover what fate has in store...</p>

    <div class="grid">
      <div class="input-group">
        <label for="userLevel">Character Level</label>
        <select id="userLevel" aria-label="Character Level">
          ${levelOptions}
        </select>
      </div>

      <div class="input-group">
        <label for="goldSpent">Gold Spent (0 - 500, 50g increments)</label>
        <select id="goldSpent" aria-label="Gold Spent">
          ${goldOptions}
        </select>
      </div>

      <div class="input-group">
        <div class="checkbox-row">
          <input type="checkbox" id="useLucky" />
          <label for="useLucky" style="margin:0;">Use Lucky Withdrawal (adds magical properties)</label>
        </div>
      </div>

      <div class="input-group">
        <div class="checkbox-row">
          <input type="checkbox" id="lockRoll" />
          <label for="lockRoll" style="margin:0;">Lock Item Type (use fixed D20 roll)</label>
        </div>
        <div id="lockedRollInput" style="display:none; margin-top:12px;">
          <label for="lockedRollValue">Locked D20 Value</label>
          <select id="lockedRollValue" aria-label="Locked D20 Value">
            ${lockedOptions}
          </select>
        </div>
      </div>
    </div>

    <button id="rollButton" onclick="rollForItem()">üé≤ Reach Into the Bag</button>

    <div id="result"></div>
  </div>

  <script>
    // show/hide locked roll select
    document.getElementById('lockRoll').addEventListener('change', (e) => {
      document.getElementById('lockedRollInput').style.display = e.target.checked ? 'block' : 'none';
    });

    async function rollForItem() {
      const button = document.getElementById('rollButton');
      const result = document.getElementById('result');
      const userLevel = parseInt(document.getElementById('userLevel').value, 10) || 1;
      const goldSpent = parseInt(document.getElementById('goldSpent').value, 10) || 0;
      const useLucky = document.getElementById('useLucky').checked;
      const lockRoll = document.getElementById('lockRoll').checked;
      const lockedRollValue = parseInt(document.getElementById('lockedRollValue').value, 10) || 1;

      button.disabled = true;
      result.classList.remove('show');

      try {
        const response = await fetch('/api/roll', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userLevel, goldSpent, useLucky, lockRoll, lockedRollValue })
        });

        if (!response.ok) {
          alert('Server error: ' + response.statusText);
          button.disabled = false;
          return;
        }

        const data = await response.json();

        let html = '<div class="dice-roll">D20: ' + data.roll + '</div>';
        html += '<div class="item-header">' + data.fullItemName + '</div>';
        html += '<div class="item-detail"><strong>Type:</strong> ' + data.itemType + '</div>';

        if (data.rarity) {
          html += '<div class="rarity ' + data.rarity.replace(/\s+/g, '_') + '">' + data.rarity + '</div>';
        }

        if (data.magicalProperties) {
          const p = data.magicalProperties;
          html += '<div class="magical-properties">';
          html += '<div><strong>‚ú® Magical Properties</strong></div>';
          if (p.spellType === 'cantrip') {
            html += '<div>Cantrip: <strong>' + p.spell + '</strong></div>';
            html += '<div>Uses: <strong>' + p.charges + '</strong></div>';
          } else {
            html += '<div>Spell: <strong>' + p.spell + '</strong></div>';
            html += '<div>Charges: <strong>' + p.charges + '</strong></div>';
            html += '<div>Recharge: <strong>' + p.recharge + '</strong></div>';
          }
          if (p.requiresAttunement) {
            html += '<div><em>Requires Attunement</em></div>';
          }
          if (p.additionalEffect) {
            html += '<div>Effect: <em>' + p.additionalEffect + '</em></div>';
          }
          html += '</div>';
        } else if (useLucky && goldSpent < 50) {
          html += '<div class="warning">‚ö†Ô∏è Not enough gold! Minimum 50 gold required for magical properties.</div>';
        }

        result.innerHTML = html;
        result.classList.add('show');
        button.disabled = false;
      } catch (error) {
        alert('Failed to roll! Try again.');
        button.disabled = false;
      }
    }
  </script>
</body>
</html>`;
}

// Main fetch handler (Cloudflare Worker)
export default {
  async fetch(request) {
    const url = new URL(request.url);

    // Check authentication only if enabled
    if (AUTH_ENABLED && !checkAuth(request)) {
      return unauthorizedResponse();
    }

    // API route for roll
    if (url.pathname === '/api/roll' && request.method === 'POST') {
      try {
        const body = await request.json();
        const {
          userLevel = 1,
          goldSpent = 0,
          useLucky = false,
          lockRoll = false,
          lockedRollValue = 1
        } = body;

        // Determine roll (honor locked roll if requested)
        const roll = lockRoll ? Number(lockedRollValue) : rollD20();
        const itemType = ITEM_TABLE[roll] || 'Unknown';
        const condition = CONDITIONS[Math.floor(Math.random() * CONDITIONS.length)];
        const itemName = generateItemName(itemType);
        const fullItemName = `${condition} ${itemName}`;

        const rarity = useLucky ? getRarity(Number(goldSpent)) : null;
        const magicalProperties = rarity ? generateMagicalProperties(rarity, Number(userLevel), useLucky) : null;

        return new Response(JSON.stringify({
          roll,
          itemType,
          condition,
          itemName,
          fullItemName,
          rarity,
          magicalProperties
        }), {
          headers: { 'Content-Type': 'application/json' }
        });

      } catch (err) {
        return new Response(JSON.stringify({ error: 'Invalid request body' }), { status: 400, headers: { 'Content-Type': 'application/json' } });
      }
    }

    // Otherwise return the HTML page
    return new Response(getHTML(), {
      headers: { 'Content-Type': 'text/html; charset=utf-8' }
    });
  }
};
      }
    </script>
  </body>
</html>
